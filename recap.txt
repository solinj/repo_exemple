--- créer un repository sur github pour le programme ---
	=> aller sur github => créer repository
	=> en local : aller dans l'emplacement du dossier qu'on veut envoyer sur github
	=> clic droit "git bash here"
	=> c'est parti pour les commandes git : elles sont toutes dispo sur la doc github :
		git init / git add . / git commit -m "first commit" / 
		git remote add origin https://github.com/NOMCOMPTEGITHUB/NOMREPOSITORY.git
		git push -u origin master
	=> aller sur github dans le repository en question, actualiser la page et vérifier que les fichiers ont bien été envoyés
ATTENTION : si en local vous faites des modifications sur vos fichiers, et que vous voulez que le repository les prenne en compte,
il faut impérativement commiter ces modification :
	=> toujours dans l'emplacement du dossier en local "git bash here"
	=> git add . / git commit -m "nouveau commit" / git push



--- créer un Job Jenkins pour exécuter la fonction ---
	=> Jenkins est sur localhost:8080
	=> "Nouveau Item" => entrer un nom de job => cliquer "construire un projet free-style"
	=> une page de configuration générale s'ouvre : aller dans "gestion de code source" =>
	sélectionner "Git" et copier-coller l'url de votre repo github (attention, il faut que l'url pointe
	bien vers votre repo, et pas sur un autre repo, ou une autre page de votre github)
	=> descendre vers "Build" => "Ajouter une étape au build" => "Python Builder"
	=> dans l'encart de script, écrire la commande d'exécution du fichier test :
		- python test.py
		ou:
		- python -m unittest test.py
Cela veut dire que lors du build, Jenkins va se concentrer sur l'exécution du script de test.
L'ajout de "-m unittest" signifie que vous appelez directement le module "unittest". (à préciser)
	=> "Sauver"
	=> Cliquer sur "Lancer un build" => Le process de build se voit dans "Historique des builds"
	=> A la fin du build, cliquer sur la petite boule rouge ou bleue puis sur "Console Output"
La "console output" détaille le processus du build, montre si les tests ont échoué ou non, etc.
Si le build fail, la console output permet de voir où se situe l'erreur.

--- créer un build sur Travis CI ---
	=> aller sur son compte travis relié au compte github
	=> en haut à droite, cliquer sur la petite flèche => "settings"
	=> la page qui s'ouvre liste les repositories github reliés à Travis => cliquer sur le bouton "sync"
	=> rafraîchir la page pour voir le nouveau repository apparaître dans la liste
	=> activer le nouveau repository en "cochant" la flèche en bleu
	=> cliquer sur "More Options" => "Trigger Build" => "Trigger custom build"
ATTENTION POUR BUILDER SUR TRAVIS IL FAUT AJOUTER A VOTRE DOSSIER/REPO UN FCHIER DE CONFIG
Le fichier de config est en langage YAML, dont le fonctionnement repose entre autres sur l'INDENTATION
	=> dans le repo, créer un fichier ".travis.yml"
Exemple de fichier .travis.yml:
-----------------------------------------
language: python

python:
 - 3.6
 - 2.7
  
script:
 - python test.py 
----------------------------------------
	=> Dans le repository github => "create new file", copier ce type de document, "commit changes"
	=> Travis comprend le changement et redémarre un nouveau build normalement


-----PULL REQUEST PROBLEMATIC----
		EN LOCAL
La commande "git pull" permet de rapattrier en local les modifications qui ont été apportées à un repo distant.
Ex : les collègues ont fait des modifs sur un projet, qu'ils ont pushées sur le repository (sur la branche master). 
Or, on a besoin de ces modifs pour faire avancer notre propre implémentation (qui se fait alors en local).
Donc : on veut rapatrier tout ce que les collègues ont fait, pour voir leur code, comment il peut s'intégrer ou non au notre,
apporter des commentaires. 
Pour cela : dans notre projet en local => "git bash here" => "git pull origin master"
		SUR REPOSITORY DISTANT (github par exemple)
On veut apporter une modification au code d'un repository étranger sur github. 
Pb: nous n'avons pas les droits pour modifier ces documents.
Donc : on va sur le fichier qu'on veut modifier, clic sur le petit crayon => "propose file change" => "create pull request"
Il s'agit d'une requête pull parce qu'on veut que le propriétaire du repository rapatrie le code qu'on lui propose.
=> Le propriétaire du repository reçoit une notification lui disant qu'un utilisateur veut modifier un de ses fichiers. Il accepte ou non.
Il accepte ou non ces changements.


	
